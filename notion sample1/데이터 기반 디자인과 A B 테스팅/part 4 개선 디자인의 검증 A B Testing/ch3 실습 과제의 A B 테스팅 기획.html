<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.553">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>ch3-실습-과제의-a-b-테스팅-기획</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="ch3 실습 과제의 A B 테스팅 기획_files/libs/clipboard/clipboard.min.js"></script>
<script src="ch3 실습 과제의 A B 테스팅 기획_files/libs/quarto-html/quarto.js"></script>
<script src="ch3 실습 과제의 A B 테스팅 기획_files/libs/quarto-html/popper.min.js"></script>
<script src="ch3 실습 과제의 A B 테스팅 기획_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="ch3 실습 과제의 A B 테스팅 기획_files/libs/quarto-html/anchor.min.js"></script>
<link href="ch3 실습 과제의 A B 테스팅 기획_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="ch3 실습 과제의 A B 테스팅 기획_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="ch3 실습 과제의 A B 테스팅 기획_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="ch3 실습 과제의 A B 테스팅 기획_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="ch3 실습 과제의 A B 테스팅 기획_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<section id="ch3.-실습-과제의-ab-테스팅-기획" class="level1">
<h1>ch3. 실습 과제의 A/B 테스팅 기획</h1>
<p>이제는 이번 단원에서 공부한 A/B 테스팅 방법론을 바탕으로 우리가 진행한 실습과제의 A디자인과 B디자인의 KPI가 차이가 있는지를 실험해보겠습니다.</p>
<p>우리 실습과제 프로젝트의 특징은 A/B 테스팅을 설문의 방법으로 한다는 것입니다. 그 이유는 우리가 실제 서비스 로그 데이터에 접근하기 어렵기 때문이라고 했었죠. 로그 데이터가 사용자의 행동을 그대로 반영하는 반면, 설문은 사용자가 의식적으로 답을 생각해내는 것이므로, 실제 행동 내용과는 다른 주관성의 개입 여지가 있습니다. 그래서 설문으로 A/B 테스팅을 하는 경우는 서비스 로그 데이터를 사용하는 방법에 비하여 아래와 같이 몇가지 고려할 점이 더 있습니다.</p>
<section id="설문을-통한-ab-테스트를-기획할-때-유의할-점" class="level3">
<h3 class="anchored" data-anchor-id="설문을-통한-ab-테스트를-기획할-때-유의할-점">설문을 통한 A/B 테스트를 기획할 때 유의할 점</h3>
<ul>
<li>적절한 샘플 크기와 설문 문항수: 충분한 데이터 수집을 위해 설문 응답자가 많아야 합니다. 최소 30명 이상의 응답자가 필요합니다. 우리 실험에서는 A 디자인에 대한 응답자 30명 이상, B디자인에 대한 응답자 30명 이상이 필요합니다. 두 그룹의 응답자 인원이 똑같지는 않아도 됩니다. 다만 너무 응답자 차이가 많이 나면 정규성과 분산 차이가 있을 수 있으므로, 비슷한 수준에서 결정합니다. 문항 수는 너무 많으면 응답자 피로가 발생하므로, 핵심 질문에 집중해 10~15문항 정도가 적절합니다. 우리 실험에서는 되도록 10개 문항 이하로 합니다.</li>
<li>설문 질문 작성 시 고려할 점:
<ul>
<li>명확성: 질문이 이해하기 쉽고 명확해야 하며, 이중 부정문을 피합니다. 설문 대상자에게 적합한 용어와 서술 방법을 사용하고, 설문 대상자는 사용자이지, 전문가가 아니므로 디자인이나 기술 관련 기술 용어들을 쓰는 것을 지양합니다.</li>
<li>중립적 표현: 편향된 질문이나 응답을 유도하는 표현을 피합니다. 특히 A,B 디자인에서 한 쪽 디자인에만 유리한 질문은 피합니다.</li>
<li>순서 효과 고려: 설문 응답자는 질문 순서에 큰 영향을 받습니다. 쉬운 질문부터 진행하고, 질문 순서가 논리적으로 구성되도록하여 질문 순서가 응답에 미치는 영향을 최소화합니다.</li>
<li>두 그룹의 설문 내용은 A, B 디자인의 내용만 제외하고 원고와 순서, 표현 및 응답 방법이 모두 동일해야합니다.</li>
</ul></li>
<li>설문 데이터 분포의 불확실성 반영: 설문은 사용자의 행동보다는 의도가 반영되기 때문에, 응답 분포가 넓어집니다. 그러므로 문항 설계에서 Likert 5점 척도보다 7점 척도를 사용하는 것이 좋습니다. 7점 척도가 응답자들이 미세한 차이를 표현할 수 있어 데이터 분포가 더 세밀하게 나타나기 때문입니다. 그리고 중립적인 선택지를 추가해 응답자의 의견이 극단으로 치우치지 않도록 합니다. 또한 각 척도의 항목이 명확하고 일관성 있게 작성되어야 합니다. 이 내용은 설문 기법 이론으로도 나와 있지만, 수년 간 A/B 테스팅을 실험해본 결과, 7점 척도의 응답이 더 명확하게 차이를 드러내는 것을 경험했습니다.</li>
<li>설문 결과의 p-value 해석: p-value가 크게 나오는 경우, 데이터가 충분하지 않거나 분산이 클 수 있습니다. 이 경우 90% 신뢰구간(유의수준 0.1)으로 해석해 보는 것도 하나의 방법입니다. 이는 더 관대한 기준을 적용해 유의미한 차이를 발견할 수 있도록 합니다. 이 부분은 해당 실습과제에서 더 자세히 설명하도록 하겠습니다.</li>
<li>설문 의견과 사용자 행동 간 차이 인정: 설문 데이터는 실제 사용자 행동과 다를 수 있습니다. 따라서 설문 결과가 실제로 행동으로 이어질 가능성을 고려하고, 필요시 추가적인 행동 데이터 분석을 통해 설문 결과를 보완합니다. 사용자 설문의 의견은 분포 범위가 넓고 불분명할 수 있으므로, 데이터 분석 시 분산이나 변동성을 주의 깊게 살펴봐야 합니다. 이는 결과의 신뢰도를 높이는 데 중요합니다. 보통 설문 응답이어서 보정이 필요한 문제는 테스트 후 의사결정 단계에서 반영합니다. 어떤 후속 조치를 할지, 디자인 수정을 어떻게 해야할지를 결정할 때 고려할 요인입니다.</li>
</ul>
</section>
<section id="실습과제-9-ab-테스팅을-위한-설문-기획" class="level3">
<h3 class="anchored" data-anchor-id="실습과제-9-ab-테스팅을-위한-설문-기획">실습과제 9: A/B 테스팅을 위한 설문 기획</h3>
<p>다음의 항목에 따라 A/B 테스팅을 위한 설문 기획서를 작성합니다.</p>
<ol type="1">
<li><p>평가 목적: 프로젝트에서 A/B테스트할 항목(KPI)을 3개 이상 서술하고, 테스트 항목 별로 질문 또는 관찰할 내용을 각 KPI 당 2개 이상 제시합니다. 실습과제 6에서 도출한 KPI를 반영합니다.</p></li>
<li><p>평가 내용 1 : 각 테스트 항목 마다 필요한 디자인 화면 (A화면, B화면)및 질문 원고, 응답 형식을 제시합니다. 제시하는 화면은 기존의 A 디자인, 개선한 B 디자인의 화면은 동일한 상황과 사용자 목표에 대응하도록 기획하며, 설문에서 제시하는 화면의 수, 제시 순서, 제시 방법까지 모두 동일하게 맞춰줍니다.</p>
<p>질문의 응답 형식은 Likert 7점 척도를 사용합니다. 질문 내용은 KPI 지표로 사용할 수 있는 내용이어야 합니다. 보통 KPI와 연계된 사용 의도, 만족도, 이해도, 선호도 등을 측정할 수 있는 질문이 사용됩니다.</p></li>
<li><p>평가 내용 2: A/B 테스트와는 상관없지만, 디자인 개선에 도움이 될 만한 추가 질문 원고를 작성합니다. 각 질문에서 무엇을 알고자 하는지를 정의하고, 이에 맞게 원고를 작성합니다. 정량/ 정성적 질문 모두 가능하며, 주관식 질문도 괜찮습니다. 이 질문들의 응답 내용은 A/B 테스트의 결과를 이해하거나 보강하는 데 사용됩니다. 단 주관식 질문은 너무 어렵지 않게 하고, 열린 응답을 하도록 하며, 전체 설문 순서에서 뒤쪽이나, 마지막 순서에 배정합니다. 보통 주관식 질문은 답하지 않는 응답자도 많으므로, 가장 중요한 질문을 주관식으로 기획하면 안됩니다.</p></li>
<li><p>테스트 형식은 구글 설문지 양식을 사용하여 두 비교 그룹에 대하여 각 30명 이상 설문 진행 예정이고, 설문 대상자에게 온라인으로 설문 링크를 제공하는 형식으로 합니다. 설문 대상자 대다수가 모바일 폰으로 설문 응답을 하게 되므로 폰 레이아웃에서 설문지 디자인이 의도대로 보이는지 확인해야합니다. A 디자인 설문지, B 디자인 설문지가 게시된 모바일 폰 화면을 나란히 놓고, 서로 비교하여 문제 부분이 있는지, 검수합니다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="ch3%20실습%20과제의%20A%20B%20테스팅%20기획/40.png" class="img-fluid figure-img"></p>
<figcaption>[그림 40] 커뮤니티 기반 산책 앱의 기존 디자인(A안)과 개선 디자인(B안)의 비교 화면과 설문 문항 예시</figcaption>
</figure>
</div></li>
</ol>
</section>
<section id="ab-테스팅을-위한-설문-기획-check-point" class="level3">
<h3 class="anchored" data-anchor-id="ab-테스팅을-위한-설문-기획-check-point">A/B 테스팅을 위한 설문 기획 Check Point!</h3>
<ul>
<li>A안과 B안의 조사 대상 페이지 수와 콘텐츠(텍스트 원고, 이미지, 테스트 대상이 아닌 GUI)를 동일하게 구성합니다. 아주 중요합니다. 가장 중요합니다!!!!!</li>
<li>모든 원고는 사용자가 쉽게 이해할 수 있는 용어로 서술합니다. 서비스의 전문 용어, 디자인의 전문 용어는 사용하지 않으며, 꼭 필요한 서비스 용어는 미리 설명합니다. 디자인 평가를 하게 하는 질문은 하지 않습니다. 우리가 측정하는 것은 KPI와 관련한 사용자 의도이지, 디자인 우수성을 평가하는 것이 아닙니다.</li>
<li>질문은 존대말을 사용하고, 현재형 질문을 사용합니다. (예: 만족하시나요? (O), 만족하셨나요?(X)), 골라주세요—&gt;선택해주세요.)</li>
<li>서비스의 사용 상황을 설명할 필요가 있으면 그 내용도 추가하여 설명합니다. 사용 상황에 알맞은 콘텐츠 원고를(시간, 지역, 상태 등) 제공합니다. (예: 당신은 11월에 혼자 도쿄 여행을 준비하고 있습니다.)</li>
<li>설문에서는 제시하는 서비스 페이지의 이미지를 중심으로 응답을 하므로 사용 경로(Flow) 중심의 검증은 한계가 있습니다. 화면 단위의 A/B 테스트 방법은 사용자 경로를 검증하기에는 적합하지 않습니다.</li>
<li>A안에 전혀 포함되지 않은 내용이나 디자인을 질문하지 않습니다. 두 개의 디자인에 대하여 객관적인 태도로 질문해야합니다.</li>
<li>설문에 제시하는 모바일 폰 테두리가 어색하지 않게 평가에 필요한 부분으로 스크롤한 이미지를 제시합니다. (사용자가 이해하기 어려운 긴 스크롤 뷰를 사용하지 않습니다.)</li>
<li>디자인 평가 대상이 아니어도 향후 디자인 개선을 위해 필요한 내용은 객관식이나 간단한 단답식 질문으로 추가 가능합니다. (평가 내용 2의 예: 검색 결과에 추가 되었으면하는 내용은 어떤 것인가요?) 또는 사용자의 타겟서비스 관련 행동을 질문할 수도 있습니다. (예: 사용하는 유사 서비스의 앱, 평소 일기쓰는 횟수 등의 질문)</li>
<li>사용자 구분이 필요한 경우에는 (예: heavy user와 light user의 구분) 조건에 맞는 사용자를 미리 선정하는 스크리닝을 실시하여 같은 조건의 사용자끼리만 비교해야합니다. 특히 A 디자인의 응답 그룹과 B 디자인의 응답 그룹이 매우 다른 성향이라면, 결과에 영향을 미치게 됩니다. A, B 응답자를 매우 다른 성향의 커뮤니티에서 따로 선정하거나, 나이, 성별, 연령 등이 확연히 다른 그룹으로 테스트하면 안됩니다.</li>
<li>자연스러운 사용자 시나리오를 중심으로 화면 순서를 배치하고, 각 화면에 관련한 질문(KPI 관련 질문, 추가 질문 모두)을 함께 배치합니다. 질문 번호는 1번부터 끝번까지 이어서 사용합니다. 화면이나 질문 카테고리별로 번호를 별도 부여하지 않습니다. 질문 섹션을 너무 많이 분리하면 설문 시간이 길어지고, 사용자들이 불편해할 수 있습니다.</li>
<li>구글 설문 폼은 리커트(Likert) 문항의 디자인 자유도가 제한적이므로 폰 화면에서 보이는 상태를 잘 고려하여 제작합니다.</li>
<li>설문 원고 제작과 내용 검수에 AI 서비스를 사용하는 것도 가능합니다. 설문 목표를 제시하고, 구체적인 질문원고와 선택지를 제안하게 하거나, 제작한 설문 원고에 문제가 없는지를 검토하도록 요청할 수 있습니다. AI를 사용할 때는 되도록 구체적으로 상황과 목표를 설명하고, 원고의 양식이나 예시등을 제시하여 응답의 정확도를 높이도록 합니다. 설문의 준비 과정과 결과 분석은 AI를 사용할 수 있지만, 설문 수행을 AI로 해서는 안됩니다. 우리는 디자인 검증을 위하여 실제 사용자의 의견을 필요로 합니다.</li>
</ul>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>