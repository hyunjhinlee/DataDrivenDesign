<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.553">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>ch1-디자인-리서치와-탐구적-데이터-분석</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="ch1 디자인 리서치와 탐구적 데이터 분석_files/libs/clipboard/clipboard.min.js"></script>
<script src="ch1 디자인 리서치와 탐구적 데이터 분석_files/libs/quarto-html/quarto.js"></script>
<script src="ch1 디자인 리서치와 탐구적 데이터 분석_files/libs/quarto-html/popper.min.js"></script>
<script src="ch1 디자인 리서치와 탐구적 데이터 분석_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="ch1 디자인 리서치와 탐구적 데이터 분석_files/libs/quarto-html/anchor.min.js"></script>
<link href="ch1 디자인 리서치와 탐구적 데이터 분석_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="ch1 디자인 리서치와 탐구적 데이터 분석_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="ch1 디자인 리서치와 탐구적 데이터 분석_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="ch1 디자인 리서치와 탐구적 데이터 분석_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="ch1 디자인 리서치와 탐구적 데이터 분석_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<section id="ch1.-디자인-리서치와-탐구적-데이터-분석-edaexploratory-data-analysis" class="level1">
<h1>ch1. 디자인 리서치와 탐구적 데이터 분석 (EDA:Exploratory Data Analysis)</h1>
<section id="디자인-리서치란" class="level3">
<h3 class="anchored" data-anchor-id="디자인-리서치란">디자인 리서치란</h3>
<p>디자인 리서치란 디자이너가 디자인 과정에서 디자인 문제를 이해하고, 주요 의사결정을 하기 위해 여러 관련 데이터를 수집, 분석, 모델링하는 과정을 말합니다. UX 디자인의 특징에 다양한 디자인 리서치 방법론이 포함될 정도로 디자인 리서치는 UX 디자인에서 매우 중요한 과정입니다. 디자인 리서치 대상인 데이터는 보통 사용자와 관련한 데이터, 프로젝트와 관련된 데이터, 그리고 프로젝트에 영향을 주는 시대나 사회, 기술의 변화에 관련한 데이터들이 포함됩니다. 디자이너는 이러한 데이터들을 적절한 방법으로 이해하고 분석하여 디자인 의사결정에 필요한 중간 산출물을 도출합니다. 디자인 리서치 과정을 통하여 디자이너가 만들어내는 중간 산출물 정보는 사용자 조사나 경쟁 제품 분석 보고서, 어피니티 다이어그램, 사용자 페르소나, 사용자 여정 지도, 콘텐츠 정보 구조도, 스토리보드, 서비스 프로토타입 등입니다. 이렇게 생성된 정보들은 디자인 해결안의 방향과 내용을 결정하는 근거가 됩니다. 그러므로 디자인 리서치가 디자인 결과물의 성공을 좌우한다고 볼 수도 있습니다. 결과적으로, 디자인 리서치는 사용자의 만족도를 높이고 비즈니스 목표를 달성하는 데 중요한 역할을 합니다.</p>
</section>
<section id="탐구적-데이터-분석이란" class="level3">
<h3 class="anchored" data-anchor-id="탐구적-데이터-분석이란">탐구적 데이터 분석이란</h3>
<p>탐구적 데이터 분석(EDA, Explanatory DataAnalysis)은 데이터 과학의 데이터 분석 방법 중의 하나로, 데이터 시각화 기술을 사용하여 데이터의 특징을 탐지하고 트렌드나 패턴을 확인하여 인사이트를 발견하는 데이터 분석 방법입니다. 탐구적 분석은 데이터 분석의 초기 단계에서 가장 많이 사용되고, 깊은 통찰력을 제공하며 분석 결과를 시각적으로 제시함으로써 비전문가들도 내용을 쉽게 이해할 수 있게 하는 특징이 있습니다. 데이터 분석 소프트웨어 플랫폼 기업인 Posit의 수석 과학자인 해들리 위컴(Hadley Wichham)은 탐구적 데이터 분석 방법을 통하여 각 변수 별로 일반적인 값과 비정상적인 값의 상태, 변수 간의 상관관계와 구조를 확인할 수 있다고 하였습니다. 그는 저서에서 탐구적 데이터 분석 과정에 대하여 [그림 4]와 같이 표현했는데, 먼저 데이터를 가져오기 하여(Import) 정리한(Tidy) 뒤, 데이터를 분석에 적합한 형태로 변형하고(Transform), 데이터 시각화(Visualize)와 데이터 모델링(Model)을 반복적으로 수행하여 목표한 분석 결과가 나오면, 분석 내용을 이해하기 좋은 형태로 소통한다고(Communicate) 설명합니다.</p>
<p>[[그림 4] 탐구적 데이터 분석 프로세스 다이어그램(9)](ch1%20%E1%84%83%E1%85%B5%E1%84%8C%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AB%20%E1%84%85%E1%85%B5%E1%84%89%E1%85%A5%E1%84%8E%E1%85%B5%E1%84%8B%E1%85%AA%20%E1%84%90%E1%85%A1%E1%86%B7%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A5%E1%86%A8%20%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%20%E1%84%87%E1%85%AE%E1%86%AB%E1%84%89%E1%85%A5%E1%86%A8%20(EDA%20E%2016ca00804b1d4f3680befbf0d8765d6f/eda.png)</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="ch1%20디자인%20리서치와%20탐구적%20데이터%20분석/eda.png" class="img-fluid figure-img"></p>
<figcaption>[그림 4] 탐구적 데이터 분석 프로세스 다이어그램(9)</figcaption>
</figure>
</div>
</section>
<section id="디자인-리서치와-탐구적-데이터-분석의-만남" class="level3">
<h3 class="anchored" data-anchor-id="디자인-리서치와-탐구적-데이터-분석의-만남">디자인 리서치와 탐구적 데이터 분석의 만남</h3>
<p>탐구적 분석에서 데이터(문제)의 현황을 탐지하고 트렌드나 패턴을 통하여 인사이트를 발견한다는 것은 더블 다이아몬드 디자인 프로세스 모델의 앞부분인 문제의 발견과 정의 단계에서 하는 활동과 매우 유사한 방법입니다. 다만 디자이너는 이 작업을 다양한 형식(비정형)의 자료를 대상으로 하고 통계 기법을 포함하여 정량, 정성, 직관적인 연구 기법을 다양하게 사용하여 수행하지만, 데이터 과학에서는 대상 데이터 형식을 정제하여 통계적 분석과 통계적 시각화 기법으로 결과를 도출한다는 점이 다릅니다.</p>
<p>그리고 위컴이 제시한 [그림 4]의 ’탐구적 데이터 분석 프로세스 다이어그램’에는 데이터의 탐색이 의미 있는 인사이트를 발견할 때까지 반복적으로 수행되는 속성이 표현되어 있는데, 이는 디자인 프로세스의 반복적 속성과도 상통합니다. 그래서 교재의 데이터 기반 디자인 실습과제에서는 디자인 리서치 과정에서 탐구적 데이터 분석 방법을 적극적으로 활용하여 프로젝트를 진행하고자 합니다. 앞으로의 디자인 리서치 실습 과제에서 데이터 시각화 그래프들을 도출하거나, 이미 공개된 분석 보고서의 그래프들을 수집하여 그래프들의 인사이트를 도출하는 탐구적 데이터 분석 방법을 사용할 예정입니다.</p>
<p>(문헌 9)Hadley Wichham, Garrett. Grolemund, 『R for Data Science(2e.)』, (2023), <a href="https://r4ds.hadley.nz/intro" class="uri">https://r4ds.hadley.nz/intro</a></p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>