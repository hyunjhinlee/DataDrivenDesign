<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.553">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>ch1-실습과제의-디자인-프로세스-주제-선정</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="ch1 실습과제의 디자인 프로세스, 주제 선정_files/libs/clipboard/clipboard.min.js"></script>
<script src="ch1 실습과제의 디자인 프로세스, 주제 선정_files/libs/quarto-html/quarto.js"></script>
<script src="ch1 실습과제의 디자인 프로세스, 주제 선정_files/libs/quarto-html/popper.min.js"></script>
<script src="ch1 실습과제의 디자인 프로세스, 주제 선정_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="ch1 실습과제의 디자인 프로세스, 주제 선정_files/libs/quarto-html/anchor.min.js"></script>
<link href="ch1 실습과제의 디자인 프로세스, 주제 선정_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="ch1 실습과제의 디자인 프로세스, 주제 선정_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="ch1 실습과제의 디자인 프로세스, 주제 선정_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="ch1 실습과제의 디자인 프로세스, 주제 선정_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="ch1 실습과제의 디자인 프로세스, 주제 선정_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<section id="ch1.-실습과제의-디자인-프로세스-주제-선정" class="level1">
<h1>ch1. 실습과제의 디자인 프로세스, 주제 선정</h1>
<section id="실습-과제의-개요-및-디자인-프로세스" class="level3">
<h3 class="anchored" data-anchor-id="실습-과제의-개요-및-디자인-프로세스">실습 과제의 개요 및 디자인 프로세스</h3>
<p>지금까지 이론적으로 공부한 데이터 기반 디자인 개념을 실습 프로젝트를 통하여 몸에 익혀봅시다. 우리가 진행할 실습 프로젝트는 관심 주제의 데이터를 선택하여 데이터를 해석하고, 해당 데이터 인사이트를 디자인에 반영할 서비스(기존 디자인, A디자인)를 선정한 뒤, 이 서비스를 데이터 기반 디자인 방법론을 통하여 개선 디자인(B 디자인)으로 제안하고, 개선 여부를 A/B 테스팅으로 검증하는 과제입니다. 개선 디자인에서 개선되지 못한 부분들은 다시 업데이트한 디자인(최종 디자인, B’ 디자인)을 제안하며 과제를 마무리합니다.</p>
<p>앞으로 우리는 A 디자인, B 디자인, B’ 디자인이라는 용어를 매우 자주 사용하게 될텐데요, A 디자인은 타겟 서비스, 즉 우리가 새로 디자인할 서비스의 기존 디자인, 현재 운영중인 디자인을 말합니다. 우리는 데이터 기반 디자인 방법론으로 A 디자인의 문제들을 연구하여 새로운 B 디자인을 해결안으로 제안할 예정입니다. 그리고 B’ 디자인은 A, B 디자인에 대한 디자인 개선 여부를 A/B 테스팅으로 검증한 뒤, 개선되지 않았다고 평가된 부분들에 대하여 디자인 수정한 해결안을 B’ 디자인으로 지칭할 예정입니다. B’ 디자인에 대하여도 A/B 테스팅을 실시하여 개선 여부를 검증하는 과정을 반복적으로 수행하여 지속적으로 서비스를 개선해 나가야하지만, 한 학기의 제한된 시간 여건에서 B’ 디자인을 제안하는 것으로 학기 과제를 마치게 됩니다.</p>
<p>실습 과제의 진행 프로세스는 [그림 23]과 같이 더블 다이아몬드 디자인 프로세스와 린 UX 디자인 프로세스의 융합으로 진행됩니다.</p>
<p>실습 과제의 내용을 주 별 활동 단위로 나누어 정리하면 다음과 같습니다.</p>
<ul>
<li>먼저 관심 데이터와 타겟 서비스를 선정해서 관련 데이터를 조사 분석하여 데이터 인사이트를 도출하고,</li>
<li>또 한 방향으로는 타겟 서비스에 대한 디자인 분석을 실시하여 디자인 인사이트를 발견합니다.</li>
<li>양 방향에서 수집한 디자인 인사이트를 종합하여 타겟 서비스에 대한 문제의 구조와 KPI를 선정하고</li>
<li>KPI를 개선할 디자인 콘셉트(가설)를 도출하여</li>
<li>이를 반영한 개선 디자인과 최소기능제품(MVP)을 제작합니다.</li>
<li>MVP 디자인에 대한 사용자 반응을 설문 조사하여 A/B 테스트를 실시하고, 개선 디자인이 목표한 KPI를 달성하였는지 검증합니다.</li>
<li>목표 KPI를 달성한 디자인 속성을 반영하고, 목표를 달성하지 못한 디자인 속성은 원인과 해결 방안을 분석, 반영하여 최종 디자인을 완성합니다.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="ch1%20실습과제의%20디자인%20프로세스,%20주제%20선정/23.png" class="img-fluid figure-img"></p>
<figcaption>[그림 23] 실습 과제의 디자인 프로세스 : Double Diamond Design Process + Lean UX Process (실습 주차 표기는 참고 사항이며, 최종 디자인(B’ 디자인)의 개발 과정은 개선 디자인(B디자인)의 개발 과정을 반복함.)</figcaption>
</figure>
</div>
<p>이제 부터는 위의 디자인 프로세스를 차근 차근 따라가면서 실습과 이론을 병행하여 설명하도록 하겠습니다. 수업에서 프로젝트 조 구성 3인 1조를 기본으로 하고 있으며, 실습 과제를 주 단위로 수행하고 있습니다.</p>
</section>
<section id="프로젝트-주제-선정" class="level3">
<h3 class="anchored" data-anchor-id="프로젝트-주제-선정">프로젝트 주제 선정</h3>
<p>일반적으로 디자인의 프로젝트를 시작할 때는 먼저 프로젝트의 주제가 정해지고, 이에 대한 데이터 리서치를 실시하는게 정상적인 방법일 것입니다. 특정 프로젝트의 주제와 관련한 데이터를 쉽게 수집할 수 있다면, 이렇게 하는 것이 맞지만, 우리는 학교에서 실습 과제를 수행하는 상황이라서, 알고 싶은 주제의 데이터를 직접 수집하는 것이 어렵습니다. 보통 기업 서비스와 관련된 데이터는 공개 되지 않지요. 또 관련 데이터를 수집한 자료가 아예 없거나, 짧은 시간에 충분한 규모의 데이터를 직접 수집하는 것이 불가능한 경우가 대부분입니다. 데이터 기반 디자인을 하기위한 데이터가 확보가 쉽지 않은 것입니다.</p>
<p>그래서 우리 실습에서는 순서를 바꾸어, 우리가 수집, 분석 가능하도록 공개된 데이터를 먼저 확보하고, 그 데이터와 관련한 서비스를 프로젝트 주제로 정하여 진행합니다. 그래서 아래와 같은 국내 데이터 제공 서비스들을 둘러보고, 관심있는 주제나 사용자 경험과 연계 가능한 데이터들을 선정하고, 이 데이터의 분석 인사이트가 적용될 수 있는 서비스를 선택하여 타겟 서비스(A 디자인)로 정합니다. 그래서 디자인 프로젝트를 정의하는 프로젝트 선언문을(Project Statement) 조금 나중에 결정하게 됩니다. 주어진 여건에서 데이터 큐레이션을 하기위한 현실적인 실습 방법으로 이해하기 바랍니다.</p>
<p>국내의 공공 데이터 제공 서비스는 통합 데이터 지도, MDIS 마이크로데이터 통합서비스, 서울열린데이터광장 등이 있습니다. 이들 서비스는 직접 분석을 해야하는 원본 데이터(raw data)도 제공하고, 원본 데이터를 분석한 가공 데이터나 시각화 그래프, 정리된 데이터 분석 보고서도 제공하고 있어서, 필요에 따라 다양한 수준의 데이터 가공이 가능합니다. 특히 우리 수업은 데이터 분석 기술을 학습하는 수업이 아니기 때문에 이미 분석된 데이터를 사용하는 비중이 높습니다. 예를들어 결혼과 관련하여 인구 통계 분석 데이터, 혼수 소비 시장 데이터, 신혼 부부를 위한 금융 서비스 데이터들이나 분석 보고서가 수집될 수 있다면 웨딩플래너 서비스를 타겟 앱 서비스로 선정하여 디자인 제안 프로젝트를 진행할 수 있습니다. 앞서의 탐구적 데이터 분석 사례에서 미세먼지 측정 데이터와 날씨 데이터를 확보하여 미세먼지 정보 서비스 앱을 디자인 제안한 것도 같은 맥락입니다.</p>
<ul>
<li>데이터 검색 및 관심 데이터 조사를 위한 국내 데이터 서비스들 (22)(23)(24)</li>
</ul>
<p><a href="https://www.bigdata-map.kr">통합 데이터지도 - 공공 민간 빅데이터 통합 검색</a></p>
<p><a href="https://mdis.kostat.go.kr/index.do">MDIS 마이크로데이터 통합서비스</a></p>
<p><a href="https://data.seoul.go.kr">열린데이터광장 메인</a></p>
</section>
<section id="실습과제-2-실습-과제의-타겟-서비스a-디자인-제안" class="level3">
<h3 class="anchored" data-anchor-id="실습과제-2-실습-과제의-타겟-서비스a-디자인-제안">실습과제 2 : 실습 과제의 타겟 서비스(A 디자인) 제안</h3>
<p>위에 제시한 공공 데이터 서비스나 보도 자료, 논문 등을 활용하여 관심 데이터 주제를 선정해주세요. 수집한 데이터들을 분석하거나 분석된 자료를 해석하여 어떤 이슈나 인사이트가 발견되는지 수집하고, 발견한 인사이트를 활용할 수 있는 앱 서비스를 제안해주세요. 적절한 앱 서비스를 선정하기 위해 여러 개의 (3가지 이상) 서비스를 비교하여 데이터 리서치와 개선 디자인 제안 실습 과제에 적합한 앱을 제시하기 바랍니다.</p>
<p>수집한 데이터는 자세히 분석할 수 있으면 좋지만, 현재 여건에서 가능한 일부만 진행해도 됩니다. 데이터 수집 및 분석은 다음 과제에서도 2-3주간 지속적으로 추가 진행할 것이므로, 완성도가 부족해도 타겟 서비스를 선정할 수 있을 정도로만 우선 진행합니다.</p>
<p>수집한 데이터(수집 출처, 데이터 형식 포함)와 데이터의 인사이트, 제안하는 기존 서비스(A 서비스)의 내용과 선정 이유를 논리적으로 구성하여 2-3페이지 분량의 제안서를 작성합니다.</p>
</section>
<section id="실습과제-2-check-point" class="level3">
<h3 class="anchored" data-anchor-id="실습과제-2-check-point">실습과제 2 Check Point!</h3>
<p>주제 선정 이후의 실습 과정을 용이하게 하기 위하여 아래의 요소들도 고려하기 바랍니다.</p>
<ul>
<li>관심 주제의 콘텐츠/ 서비스 내용을 분석하여 데이터 인사이트를 낼 수 있는 데이터나 데이터 시각화 자료가 존재해야함. (있다고 가정하면 안됨)</li>
<li>생각하는 서비스의 내용에 대하여 기존에 출시되어 있는 서비스(A안)가 존재해야함. A서비스와 B서비스를 합쳐서 기존에 없던 C서비스를 만드는 프로젝트는 안됨 (A/B 테스트 불가, 서비스 내용이 다르면 디자인을 비교할 수 없음)</li>
<li>사회 정책을 개발하거나 홍보하는 주제가 아니라 개인의 사용자 경험(인지, 의사결정, 행위)을 개선하는 주제여야함. 의견을 묻는 것이 아닌 행동 변화를 확인하는 주제여야 함.</li>
<li>타겟 서비스의 내용이나 디자인에 대하여 설문으로 사용자 피드백을 얻는 것이 가능해야함. 사용자 의견을 얻기 위하여 서비스 경험 시간이 많이 필요한 서비스는 지양함.(예를 들어 학습 경험은 학습 시간, 러닝 커브가 필요하여 짧은 시간에 앱 화면을 보는 경험 만으로는 평가가 어려움)</li>
<li>어떻게 서비스를 테스트 할 것인가에 대한 고려가 필요함. 외국인 대상의 서비스면 외국인 대상으로, 아동 대상의 서비스면 아동 대상으로 테스트 해야하므로, 테스트를 위하여 60명 이상의 평가 인원 참여가(A테스트 30명, B테스트 30명) 가능한 주제를 선택함. 평가 참여 인원은 많을수록 좋음.</li>
</ul>
<p>(문헌22) 통합 데이터지도-공공 민간 빅데이터 통합검색 https://www.bigdata-map.or</p>
<p>(문헌23) MDIS 마이크로데이터 통합서비스 https://mdis.kostat.go.kr</p>
<p>(문헌24) 서울 열린데이터광장 https://data.seoul.go.kr</p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>