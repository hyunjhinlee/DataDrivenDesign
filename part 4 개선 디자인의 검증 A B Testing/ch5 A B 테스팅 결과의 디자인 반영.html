<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.553">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>ch5-a-b-테스팅-결과의-디자인-반영</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="ch5 A B 테스팅 결과의 디자인 반영_files/libs/clipboard/clipboard.min.js"></script>
<script src="ch5 A B 테스팅 결과의 디자인 반영_files/libs/quarto-html/quarto.js"></script>
<script src="ch5 A B 테스팅 결과의 디자인 반영_files/libs/quarto-html/popper.min.js"></script>
<script src="ch5 A B 테스팅 결과의 디자인 반영_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="ch5 A B 테스팅 결과의 디자인 반영_files/libs/quarto-html/anchor.min.js"></script>
<link href="ch5 A B 테스팅 결과의 디자인 반영_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="ch5 A B 테스팅 결과의 디자인 반영_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="ch5 A B 테스팅 결과의 디자인 반영_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="ch5 A B 테스팅 결과의 디자인 반영_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="ch5 A B 테스팅 결과의 디자인 반영_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<section id="ch5.-ab-테스팅-결과의-디자인-반영" class="level1">
<h1>ch5. A/B 테스팅 결과의 디자인 반영</h1>
<p>이제 실습 과제의 마지막 단계입니다. 우리는 실습 프로젝트에서 개선하고자 한 KPI가 개선 디자인(B안)을 통하여 개선 되었는지의 여부를 A/B 테스트로 확인했습니다. 이 결과를 어떻게 디자인에 반영해야 할까요? 다음의 사항들을 고려하여 디자인 반영 계획을 도출합니다.</p>
<ul>
<li><p>테스트에서 KPI가 개선 되었음을 확인한 B안의 디자인 개선안들은 변경 확정을 합니다.</p>
<p>다만 개선 디자인 부분들이 화면 경로의 앞, 뒤의 연계 화면에서 잘 이어지는지, 충돌의 여지가 있는지를 확인해야합니다. 같은 개선 디자인 요소가 반영되는 다른 화면들의 변경을 확정할 때도 다른 디자인 고려 사항이 있는지를 확인한 후에 변경 결정을 합니다.</p></li>
<li><p>테스트에서 KPI가 개선 되지 않은 부분은 원인 분석을 실시하여 개선 디자인을 수정(B’ 디자인)합니다.</p>
<p>응답자 리크루팅, 질문 문항의 문구, 응답 선택지 디자인 등 테스트 설계가 잘못되었으면, 테스트를 수정하여 다시 실시해야하고, 개선 디자인에 문제가 있었으면, 개선 디자인을 변경해야 합니다. 또는 개선 디자인은 잘 진행 되었어도, 평가 대상이 아닌 다른 그래픽 요소 등에 영향을 받아 문제가 생길 수도 있습니다. 예를들어, 테스트 화면에 사용한 이미지의 크기나 이미지의 내용이 영향을 주어서 테스트 결과의 왜곡을 경험한 사례도 있습니다. 보통 모바일 화면 레이아웃에서 눈에 띄는 이미지를 사용하는 경우 응답자의 주의를 과도하게 분산하는 상황이 발생할 수 있습니다. 또 설문에서 수집한 데이터 내용을 참조하여 영향을 준 원인을 유추하는 것도 가능합니다. 이러한 원인들은 프로젝트의 성격에 따라 다양하게 나타납니다. 명확한 원인을 찾았다면 문제를 해결하여 테스트를 반복하면 되고, 원인이 불명확하다면 여러 가정에 따라 테스트 수정안을 여러가지로 준비하여 하나씩 확인해나가야 합니다.</p></li>
<li><p>그리고 KPI에 영향을 미치지 않는 요소라고 하더라도, 서비스의 전반적인 디자인 일관성이나 완성도 개선을 위해서, 또는 설문에서 추가적으로 제안된 사항에 대하여도 필요성을 판단하여 디자인 개선을 진행합니다.</p>
<p>여기까지 디자인 개선 계획을 확정했다면, 이상적인 서비스의 흐름을 따라서 사용자 경험의 문제가 있는지를 검토하고, 디자인 개선을 완료합니다. 이제 린 디자인 프로세스에 의한 UX 디자인의 한 라운드 (Learn-Build-Measure-Learn)가 완료되었습니다.</p></li>
<li><p>린 디자인 프로세스는 반복적이고, 지속적인 프로세스입니다.</p>
<p>기존 디자인(A 디자인)의 문제를 발견하고, KPI를 개선할 수 있는 개선 디자인(B 디자인)을 제시하여 두 디자인의 KPI 값에 대한 개선이 이루어졌는지를 측정하여 개선 디자인을 평가하는 한 라운드가 완료 되었지만, 실무적 입장에서는 타겟 서비스에 대한 린 디자인 프로세스가 이제 막 시작된 상태라고 할 수 있습니다. 이 프로세스는 목표한 KPI가 모두 개선될 때까지 디자인 수정을 시행하면서 테스트를 반복하게 될 것입니다. 그 외에 새로운 디자인 목표가 발생하거나, 비즈니스에 환경 변화가 있을 때 이 과정은 새로운 라운드를 시작하게 됩니다. 이 반복적인 개선과 검증의 순환은 서비스가 종료되는 시점까지 계속 모니터링 되고, 지속될 것입니다.</p></li>
</ul>
<section id="실습과제-11-프로젝트의-최종-디자인-개선안-디자인-b-제시" class="level3">
<h3 class="anchored" data-anchor-id="실습과제-11-프로젝트의-최종-디자인-개선안-디자인-b-제시">실습과제 11: 프로젝트의 최종 디자인 개선안 (디자인 B’) 제시</h3>
<p>A/B 테스트의 결과를 반영한 최종 디자인 개선안(디자인 B’)를 제시합니다. B’ 디자인은 서비스의 실질적인 최종 디자인은 아닙니다. 새로운 디자인 개선안에 대하여 A/B 테스트를 했을 때 KPI 목표를 만족하지 못하거나 다른 디자인 문제가 발생할 수도 있고, 현 시점에서 디자인 확정이 되어도 향후에 지속적인 개선과 검증이 필요할 것이 때문입니다. 다만, 우리 실습 과제로서는 마지막 단계의 디자인 개선이므로 최종 디자인 개선안으로 표기하겠습니다.</p>
<ul>
<li>KPI가 개선 되지 않았던 화면들의 디자인에 대하여 항목 별로 원인을 서술하고, 이를 디자인에 반영한 프로젝트의 최종 디자인 개선안(B’ 디자인) 화면을 제안합니다.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="ch5%20A%20B%20테스팅%20결과의%20디자인%20반영/42.png" class="img-fluid figure-img"></p>
<figcaption>[그림 32] 교통 약자를 위한 지하철 승강장 정보 화면에 대한 A/B 테스팅 결과와 B 디자인의 개선 방향 제안 예시</figcaption>
</figure>
</div>
<ul>
<li>기존 디자인(A 디자인), 개선 디자인(B 디자인), 최종 개선 디자인(B’ 디자인)의 화면들을 서로 비교하여 변화를 이해할 수 있게 서술합니다.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="ch5%20A%20B%20테스팅%20결과의%20디자인%20반영/43.png" class="img-fluid figure-img"></p>
<figcaption>[그림 33] [그림 32]의 프로젝트에 대한 기존 디자인 A,개선 디자인 B, 최종 디자인 B’ 화면의 디자인 비교 서술 예시</figcaption>
</figure>
</div>
<ul>
<li>최종 디자인(B’ 디자인)을 사용자의 사용 시나리오를 따라 제시하여 최종 디자인의 사용자 경험을 전체적으로 이해할 수 있도록 설명합니다.</li>
<li>필요하다면 최종 디자인(B’ 디자인)에 대한 검증 계획을 제안합니다. 이 테스트는 이미 수행한 개선 디자인(B 디자인) 테스트의 경험과 데이터를 활용하여 참여자, 문항, 선택지, 등의 요소들에 대한 다음 테스트 계획을 수립합니다. 예를 들어, 진행할 테스트의 문항이 이전 테스트와 동일한 경우에는 두번째 테스트에서 기존 디자인 (A 디자인)에 대한 평가를 새로 하지 않고, 이미 진행한 A 디자인 데이터와 새로 수집한 B’ 디자인 데이터를 비교하여 작업 부담을 줄일 수도 있고, 기존 디자인에 대한 설문을 추가로 시행한 뒤, 이전 설문의 데이터와 합쳐서 테스트 집단의 규모를 크게 할 수 도 있을 것입니다. 테스트가 반복될 수록 테스트의 수행 과정은 더 효율적으로 관리할 수 있고, 축적된 데이터들을 통하여 추가 인사이트들을 발견할 수 있습니다.</li>
</ul>
<p>여기까지 데이터 기반 디자인과 A/B 테스팅의 실습과제들을 마치도록 하겠습니다. 실습에 참여하시느라 수고하셨습니다.</p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>